// use a separate module for privacy
mod oracle {
    use crate::s1c07::aes_128_ecb_encrypt;
    use rand::{thread_rng, Rng};

    pub struct Oracle {
        content: Vec<u8>,
        key: [u8; 16],
    }

    impl Oracle {
        pub fn new(content: &[u8]) -> Self {
            let content = content.to_owned();

            let mut key = [0u8; 16];
            thread_rng().fill(&mut key[..]);

            Self { content, key }
        }

        pub fn process(&self, input: &[u8]) -> Vec<u8> {
            let mut rng = thread_rng();
            // random-prefix || attacker-controlled || target-bytes
            let rp_len = rng.gen::<u8>();
            let mut clear: Vec<u8> = (0..rp_len).map(|_| rng.gen()).collect();
            clear.extend_from_slice(input);
            clear.extend_from_slice(&self.content);

            // Use random padding; we could use PKCS7 or any other
            // deterministic padding, this is just to illustrate that the
            // attacker doesn't need any knowledge of the padding bytes.
            let mut padding = [0u8; 16];
            thread_rng().fill(&mut padding[..]);
            let pad_len = 16 - clear.len() % 16;
            clear.extend_from_slice(&padding[..pad_len]);

            aes_128_ecb_encrypt(&self.key, &clear).unwrap()
        }
    }
}

use oracle::Oracle;

// Find the content hidden in the Oracle
// victim.content is private and can't be read
pub fn attack(_victim: &Oracle) -> Vec<u8> {
    b"Not implemented yet".to_vec()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[ignore]
    fn challenge() {
        let content = b"Rollin' in my 5.0
With my rag-top down so my hair can blow
The girlies on standby waving just to say hi
Did you stop? No, I just drove by
";
        let oracle = Oracle::new(content);
        assert_eq!(attack(&oracle), content);
    }
}
